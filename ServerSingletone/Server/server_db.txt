// Используется стандарт языка ISO C++17
// Для смены стандарта необходимо пройти по такому пути параметров
// Проект -> Свойства -> C/C++ -> Язык -> Стандарт языка C++

#include <iostream>
#include <fstream>
#include <unordered_map>
#include <map>
#include <vector>
#include <queue>
#include <limits>
#include <string>
#include <mutex>
#include <sstream>

using Vertex = int;
using Weight = double;
using AdjList = std::unordered_map<Vertex, std::vector<std::pair<Vertex, Weight>>>;

// Класс-синглтон для работы с графом и шифром Виженера
class DBServer {
public:
    // Получение единственного экземпляра (синглтон)
    static DBServer& getInstance() {
        static DBServer instance;
        return instance;
    }

    DBServer(const DBServer&) = delete;
    DBServer& operator=(const DBServer&) = delete;

    // Добавление ребра в граф
    void addEdge(Vertex u, Vertex v, Weight w) {
        std::lock_guard<std::mutex> lock(mutex_);
        graph_[u].emplace_back(v, w);
        graph_[v].emplace_back(u, w); // граф неориентированный
    }

    // Алгоритм Дейкстры для нахождения кратчайших путей от источника
    std::vector<Weight> shortestPath(Vertex src) {
        std::lock_guard<std::mutex> lock(mutex_);
        const auto INF = std::numeric_limits<Weight>::infinity();

        // Определение максимальной вершины для задачи размера вектора расстояний (размер)
        Vertex max_v = 0;
        for (auto& kv : graph_) if (kv.first > max_v) max_v = kv.first;

        std::vector<Weight> dist(max_v + 1, INF);
        dist[src] = 0;

        // Очередь с приоритетом для выбора минимального расстояния
        std::priority_queue<std::pair<Weight, Vertex>, std::vector<std::pair<Weight, Vertex>>, std::greater<>> pq;
        pq.emplace(0, src);

        // Основной цикл алгоритма подбора минимального расстояния
        while (!pq.empty()) {
            auto [d, u] = pq.top(); pq.pop(); // Извлечение вершины с минимальным расстоянием
            if (d > dist[u]) continue; // Если же расстояние больше вершины, то это устаревшая информация
            for (auto& [v, w] : graph_[u]) { // Перебор всех соседних вершин
                if (dist[v] > d + w) { // Обновление пути при нахождении более короткого
                    dist[v] = d + w;
                    pq.emplace(dist[v], v);
                }
            }
        }
        return dist;
    }

    // Сохранение всей базы данных (граф + виженер)
    bool saveDatabase(const std::string& filename) {
        std::lock_guard<std::mutex> lock(mutex_);
        std::ofstream ofs(filename);
        if (!ofs) return false;

        ofs << "[GRAPH]\n";
        for (auto& [u, edges] : graph_) {
            for (auto& [v, w] : edges) {
                if (u < v) // во избежания дублирования рёбер
                    ofs << u << ' ' << v << ' ' << w << '\n';
            }
        }

        ofs << "[VIGENERE]\n";
        for (auto& [key_pair, res] : vigenere_halves_) {
            ofs << key_pair.first << '|' << key_pair.second << '|' << res << '\n';
        }
        return true;
    }

    // Загрузка всей базы данных (граф + виженер)
    bool loadDatabase(const std::string& filename) {
        std::lock_guard<std::mutex> lock(mutex_);
        std::ifstream ifs(filename);
        if (!ifs) return false;

        graph_.clear();
        vigenere_halves_.clear();

        std::string line;
        enum Section { NONE, GRAPH, VIGENERE } section = NONE;


        while (std::getline(ifs, line)) {
            if (line == "[GRAPH]") {
                section = GRAPH;
            }
            else if (line == "[VIGENERE]") {
                section = VIGENERE;
            }
            else if (!line.empty()) {
                if (section == GRAPH) {
                    Vertex u, v; Weight w;
                    std::istringstream iss(line);
                    iss >> u >> v >> w;
                    graph_[u].emplace_back(v, w);
                    graph_[v].emplace_back(u, w);
                }
                else if (section == VIGENERE) {
                    auto p1 = line.find('|');
                    auto p2 = line.find('|', p1 + 1);
                    std::string k1 = line.substr(0, p1);
                    std::string k2 = line.substr(p1 + 1, p2 - p1 - 1);
                    std::string res = line.substr(p2 + 1);
                    vigenere_halves_[{k1, k2}] = res;
                }
            }
        }
        return true;
    }

    // Сохранение результата шифрования
    void storeHalfKey(const std::string& half_key, const std::string& text, const std::string& result) {
        std::lock_guard<std::mutex> lock(mutex_);
        vigenere_halves_[{half_key, text}] = result;
    }

    // Получение сохранённого результата
    bool getHalfKey(const std::string& half_key, const std::string& text, std::string& out) {
        std::lock_guard<std::mutex> lock(mutex_);
        auto it = vigenere_halves_.find({ half_key, text });
        if (it != vigenere_halves_.end()) {
            out = it->second;
            return true;
        }
        return false;
    }

    // Вывод содержимого графа и данных по шифру
    void printData(std::ostream& os = std::cout) {
        std::lock_guard<std::mutex> lock(mutex_);
        os << "[GRAPH]\n";
        for (const auto& [u, edges] : graph_) {
            for (const auto& [v, w] : edges) {
                if (u < v) os << u << " -> " << v << " : " << w << '\n';
            }
        }
        os << "[VIGENERE]\n";
        for (const auto& [key_pair, res] : vigenere_halves_) {
            os << "Ключ: " << key_pair.first << ", Текст: " << key_pair.second << ", Результат: " << res << '\n';
        }
    }

private:
    DBServer() = default;
    ~DBServer() = default;

    AdjList graph_; // граф представлен в виде списка смежности
    std::map<std::pair<std::string, std::string>, std::string> vigenere_halves_; // хранилище шифров
    std::mutex mutex_; // защита данных для многопоточности
};

int main() {
    setlocale(LC_ALL, "Russian");
    auto& db = DBServer::getInstance();
    std::string dbPath;

    std::cout << "Введите путь к базе данных (один файл): ";
    std::cin >> dbPath;

    std::ofstream log(dbPath + "_log.txt");

    std::cout << "Загрузить существующую БД? (1-да, 0-нет): ";
    int choice; std::cin >> choice;
    if (choice == 1) {
        if (db.loadDatabase(dbPath)) {
            log << "База данных успешно загружена\n";
            db.printData();
            std::cout << "Изменить базу данных? (1-да, 0-нет): ";
            int edit; std::cin >> edit;
            if (!edit) return 0;
        }
        else {
            log << "Ошибка загрузки базы данных\n";
        }
    }

    std::cout << "Введите число рёбер: ";
    int m; std::cin >> m;
    for (int i = 0; i < m; ++i) {
        Vertex u, v; Weight w;
        std::cout << "Ребро " << i + 1 << " (u v w): ";
        std::cin >> u >> v >> w;
        db.addEdge(u, v, w);
        log << "Добавлено ребро: " << u << " - " << v << " вес: " << w << "\n";
    }

    std::cout << "Введите источник для Дейкстры: ";
    Vertex src; std::cin >> src;
    auto dist = db.shortestPath(src);
    std::cout << "Дистанции от " << src << ":";
    log << "Результаты Дейкстры от вершины " << src << ":\n";
    for (size_t i = 0; i < dist.size(); ++i) {
        if (dist[i] < std::numeric_limits<Weight>::infinity()) {
            std::cout << " [" << i << ": " << dist[i] << "]";
            log << i << " => " << dist[i] << "\n";
        }
    }
    std::cout << std::endl;


    std::string half, text, result;
    std::cout << "Введите половину ключа, текст и результат (через пробел): ";
    std::cin >> half >> text >> result;
    db.storeHalfKey(half, text, result);

    std::string out;
    if (db.getHalfKey(half, text, out)) {
        std::cout << "Сохранённый результат: " << out << std::endl;
        log << "Введено: ключ=" << half << ", текст=" << text << ", результат=" << result << "\n";
    }

    if (db.saveDatabase(dbPath)) log << "База данных успешно сохранена\n";
    else log << "Ошибка сохранения базы данных\n";

    log.close();
    return 0;
}
